【项目信息】
项目名称 : thread
中文名称 : 线程
项目版本 : version 1.0

主要技术 : 线程原理、线程技术、多线程、并发原理、并发技术

项目描述 : 

项目备注 : 

【项目规划】

1) 主线程问题
主线程不能比子线程提前结束，不然很多效果无法观看，因此可以让主线程休眠
适当的时间，给足够的时间给众多的子线程去运行，并输出运行结果.

2) 现场恢复机制
凡是线程执行问题，都涉及到现场恢复事务。因为一个线程的存在与否，是决定于其run方法
是否已执行结束，run方法一旦执行完毕，则该线程的使命已经结束，虽然该线程对象依然存在，
但是已经丧失使命，这也就是为什么线程不能重复start的原因.
正是因为，一个线程对象都只有一次执行run的机会，因此遇到线程阻塞、被挂起、休眠、等待等让
线程暂停工作的情况，一旦恢复之后，线程将继续之前的工作，即从上一次被暂停的地方开始继续
执行.

3) 对象锁问题
sleep()方法 (只让出CPU资源，但不让出对象锁)
　　	sleep()使当前线程进入停滞状态（阻塞当前线程），让出CUP的使用、
	  	目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会;
　　	sleep()是Thread类的Static(静态)的方法；因此他不能改变对象的机锁，所以当在一个Synchronized块中调用Sleep()方法是，
	  	线程虽然休眠了，但是对象的机锁并木有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁）。
　  	在sleep()休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，
		除非此线程具有更高的优先级。 


wait()方法 (让出对象锁，超时后还需要返还对象锁)
　　	wait()方法是Object类里的方法；当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，
		同时失去（释放）了对象的机锁（暂时失去机锁，wait(long timeout) 超时之后自动把自己唤醒，相当于给自己调闹钟）；
		其他线程可以访问；
　　	wait()使用notify或者notifyAlll或者指定睡眠时间来唤醒当前等待池中的线程。
　　	wiat()必须放在synchronized block中，否则会在program runtime时扔出”java.lang.IllegalMonitorStateException“异常。

所以sleep()和wait()方法的最大区别是：
　	sleep()睡眠时，保持对象锁，仍然占有该锁；
　	而wait()睡眠时，释放对象锁。
	但是wait()和sleep()都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException（但不建议使用该方法）。

4) 4个线程，2个线程对j增1,2个线程对j减1，并输出j，共操作100次.

5) 守护线程 (Daemon Thread)
Thread.setDaemon(true); 在Thread.start()之前设置，在守护线程中构造的线程对象也是守护线程
使用注意: 不能访问固有的资源(读写/计算逻辑)，因为它会在任何时候/操作中间发生中断
存在意义: 主线程结束时，守护线程自动关闭，省去了关闭子线程的操作.

10) 线程组
ThreadGroup.setDeamon(true); 表示线程组中最后一个线程执行完成或被销毁时，该线程组自动销毁.

15) 关系
线程和线程之间，涉及 等待、通讯
线程和资源之间，涉及 等待、资源(对象)锁、























